# 04-性能优化

## 概述

性能是用户体验的重要组成部分，需要在开发阶段就考虑性能问题。

## 数据库性能

### 索引优化

```sql
-- ✅ 为常用查询字段添加索引
CREATE INDEX idx_user_username ON user(username);
CREATE INDEX idx_order_user_id ON `order`(user_id);

-- ✅ 复合索引遵循最左前缀原则
CREATE INDEX idx_order_user_status ON `order`(user_id, status);
-- 可以支持: WHERE user_id = ? AND status = ?
-- 可以支持: WHERE user_id = ?
-- 不支持: WHERE status = ?

-- ❌ 避免在索引列上使用函数
SELECT * FROM user WHERE YEAR(create_time) = 2025;
-- ✅ 改为范围查询
SELECT * FROM user WHERE create_time >= '2025-01-01' AND create_time < '2026-01-01';
```

### N+1问题

```java
// ❌ N+1问题
List<Order> orders = orderMapper.selectList();
for (Order order : orders) {
    User user = userMapper.selectById(order.getUserId()); // 每个订单查一次
}

// ✅ 批量查询
List<Order> orders = orderMapper.selectList();
Set<Long> userIds = orders.stream()
    .map(Order::getUserId)
    .collect(Collectors.toSet());
Map<Long, User> userMap = userMapper.selectBatchIds(userIds).stream()
    .collect(Collectors.toMap(User::getId, Function.identity()));

orders.forEach(order -> order.setUser(userMap.get(order.getUserId())));
```

### 分页查询

```java
// ✅ 使用游标分页（大数据量）
@Select("""
    SELECT * FROM order
    WHERE id > #{lastId}
    ORDER BY id
    LIMIT #{pageSize}
    """)
List<Order> selectByPage(@Param("lastId") Long lastId, @Param("pageSize") int pageSize);

// ❌ 避免深度分页
SELECT * FROM order LIMIT 1000000, 10; // 性能差
```

## 缓存策略

### Redis缓存

```java
// ✅ 合理使用缓存
@Cacheable(value = "user", key = "#id", unless = "#result == null")
public User getById(Long id) {
    return userMapper.selectById(id);
}

@CacheEvict(value = "user", key = "#user.id")
public void update(User user) {
    userMapper.updateById(user);
}

// ✅ 设置合理的过期时间
@Cacheable(value = "user", key = "#id", cacheManager = "cacheManager")
// 配置中设置TTL为30分钟
```

### 缓存穿透防护

```java
// ✅ 缓存空值防止穿透
@Cacheable(value = "user", key = "#id")
public User getById(Long id) {
    User user = userMapper.selectById(id);
    if (user == null) {
        // 缓存空对象，设置较短过期时间
        return new User(); // 或使用特殊标记
    }
    return user;
}

// ✅ 使用布隆过滤器
@Autowired
private BloomFilter<Long> userIdBloomFilter;

public User getById(Long id) {
    if (!userIdBloomFilter.mightContain(id)) {
        return null; // 一定不存在
    }
    return getFromCacheOrDb(id);
}
```

## 并发优化

### 异步处理

```java
// ✅ 使用异步处理非关键路径
@Async
public CompletableFuture<Void> sendNotification(Long userId, String message) {
    // 发送通知
}

// 调用
sendNotification(userId, message); // 不阻塞主流程
```

### 批量处理

```java
// ❌ 循环单条插入
for (User user : users) {
    userMapper.insert(user);
}

// ✅ 批量插入
userMapper.insertBatch(users);

// ✅ 分批处理大数据
List<List<User>> batches = Lists.partition(users, 500);
for (List<User> batch : batches) {
    userMapper.insertBatch(batch);
}
```

## JVM优化

### 对象复用

```java
// ❌ 频繁创建对象
for (int i = 0; i < 10000; i++) {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    sdf.format(date);
}

// ✅ 使用ThreadLocal复用
private static final ThreadLocal<SimpleDateFormat> DATE_FORMAT =
    ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

DATE_FORMAT.get().format(date);

// ✅ 更好：使用Java 8 DateTimeFormatter（线程安全）
private static final DateTimeFormatter FORMATTER =
    DateTimeFormatter.ofPattern("yyyy-MM-dd");
```

### 集合初始化

```java
// ✅ 预设集合大小
List<User> users = new ArrayList<>(100);
Map<Long, User> userMap = new HashMap<>(100);

// ❌ 默认大小，频繁扩容
List<User> users = new ArrayList<>();
```

## 接口性能

### 响应时间要求

| 接口类型 | 响应时间要求 |
|----------|-------------|
| 列表查询 | < 500ms |
| 详情查询 | < 200ms |
| 创建/更新 | < 1s |
| 导出 | < 30s |

### 优化手段

```java
// ✅ 只返回必要字段
@Select("SELECT id, username, email FROM user WHERE id = #{id}")
UserSimpleDTO getSimpleById(Long id);

// ✅ 使用DTO投影
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT new com.example.UserDTO(u.id, u.username) FROM User u")
    List<UserDTO> findAllSimple();
}

// ✅ 启用GZIP压缩
server:
  compression:
    enabled: true
    mime-types: application/json,text/html,text/xml
```

## 性能监控

### 关键指标

- 响应时间（P50, P95, P99）
- 吞吐量（QPS）
- 错误率
- CPU/内存使用率

### 慢查询日志

```yaml
# MyBatis慢查询日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# MySQL慢查询
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1
```

## 性能检查清单

- [ ] 数据库查询有索引
- [ ] 无N+1查询问题
- [ ] 热点数据有缓存
- [ ] 大批量操作分批处理
- [ ] 接口响应时间达标
- [ ] 无内存泄漏风险

## 关联 Agent

- java-developer：性能优化实现
- code-reviewer：性能问题检查
