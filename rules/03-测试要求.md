# 03-测试要求

## 概述

测试是保证代码质量的关键，所有新功能必须有对应测试。

## 覆盖率要求

| 指标 | 最低要求 | 目标值 |
|------|----------|--------|
| 行覆盖率 | 80% | 90% |
| 分支覆盖率 | 70% | 85% |
| 方法覆盖率 | 85% | 95% |

## 测试类型

### 1. 单元测试

测试单个类或方法，使用Mock隔离依赖。

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserMapper userMapper;

    @InjectMocks
    private UserServiceImpl userService;

    @Test
    @DisplayName("根据ID获取用户-成功")
    void getById_success() {
        // Given
        Long id = 1L;
        UserDO user = new UserDO();
        user.setId(id);
        user.setUsername("test");
        when(userMapper.selectById(id)).thenReturn(user);

        // When
        UserDTO result = userService.getById(id);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getUsername()).isEqualTo("test");
        verify(userMapper).selectById(id);
    }

    @Test
    @DisplayName("根据ID获取用户-不存在")
    void getById_notFound() {
        // Given
        Long id = 999L;
        when(userMapper.selectById(id)).thenReturn(null);

        // When & Then
        assertThrows(NotFoundException.class, () -> {
            userService.getById(id);
        });
    }
}
```

### 2. 集成测试

测试多个组件协作。

```java
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
class UserControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("创建用户-成功")
    void createUser_success() throws Exception {
        String request = """
            {
                "username": "newuser",
                "email": "new@example.com"
            }
            """;

        mockMvc.perform(post("/system/user")
                .contentType(MediaType.APPLICATION_JSON)
                .content(request))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(0))
            .andExpect(jsonPath("$.data").isNumber());
    }
}
```

### 3. E2E测试

使用Playwright测试完整用户流程。

```typescript
test('用户登录流程', async ({ page }) => {
    await page.goto('/login');
    await page.fill('[name=username]', 'admin');
    await page.fill('[name=password]', 'admin123');
    await page.click('button[type=submit]');

    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('.user-info')).toContainText('admin');
});
```

## TDD工作流

```
1. 红灯：编写测试（测试应该失败）
        │
        ▼
2. 绿灯：编写最小实现（测试通过）
        │
        ▼
3. 重构：优化代码（保持测试通过）
        │
        ▼
4. 验证：检查覆盖率（≥80%）
```

## 测试命名规范

```java
// 格式：方法名_场景_预期结果
@Test
void getById_userExists_returnsUser() {}

@Test
void getById_userNotExists_throwsException() {}

@Test
void create_validInput_returnsNewId() {}

@Test
void create_duplicateName_throwsException() {}
```

## 测试数据

### 使用Builder模式

```java
// 测试数据构建器
public class UserTestBuilder {
    private Long id = 1L;
    private String username = "testUser";
    private String email = "test@example.com";

    public static UserTestBuilder aUser() {
        return new UserTestBuilder();
    }

    public UserTestBuilder withId(Long id) {
        this.id = id;
        return this;
    }

    public UserTestBuilder withUsername(String username) {
        this.username = username;
        return this;
    }

    public UserDO build() {
        UserDO user = new UserDO();
        user.setId(id);
        user.setUsername(username);
        user.setEmail(email);
        return user;
    }
}

// 使用
UserDO user = UserTestBuilder.aUser()
    .withId(1L)
    .withUsername("admin")
    .build();
```

## 测试隔离

### 数据库测试

```java
@SpringBootTest
@Transactional  // 测试后自动回滚
class UserRepositoryTest {
    // 每个测试相互隔离
}
```

### Mock外部服务

```java
@MockBean
private ThirdPartyService thirdPartyService;

@Test
void test() {
    when(thirdPartyService.call()).thenReturn("mocked");
    // 测试代码
}
```

## 豁免规则

以下代码可豁免覆盖率要求：
- DO/DTO实体类（Lombok生成）
- 配置类
- 启动类Main方法

## 测试检查清单

### 提交前检查

- [ ] 所有测试通过
- [ ] 覆盖率达标（≥80%）
- [ ] 测试命名规范
- [ ] 无跳过的测试（@Disabled）
- [ ] 测试相互独立

### 测试质量

- [ ] 测试有意义的场景
- [ ] 包含边界条件测试
- [ ] 包含异常场景测试
- [ ] 断言具体明确

## 关联Agent

- 07-测试专家.md：TDD实践和测试策略
